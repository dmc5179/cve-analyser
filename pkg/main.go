package main

import (
	"encoding/csv"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"os"
	"strings"
	"sync"
)

const hydraUrl string = "https://access.redhat.com/hydra/rest/securitydata/cve/"
const PyxisUrl string = "https://catalog.redhat.com/api/containers/v1"

type HydraResponse struct {
	CVE          string `json:"name"`
	Severity     string `json:"threat_severity"`
	Statement    string `json:"statement"`
	Upstream_fix string `json:"upstream_fix"`
	Data_Fixed   []struct {
		Product_name   string `json:"product_name"`
		Advisory       string `json:"advisory"`
		CPE            string `json:"cpe"`
		RPM            string `json:"package"`
		Product_impact string `json:"impact,omitempty"`
	} `json:"affected_release"`
	Data_NotFixed []struct {
		Product_name   string `json:"product_name"`
		Fix_State      string `json:"fix_state"`
		CPE            string `json:"cpe"`
		RPM            string `json:"package_name"`
		Product_impact string `json:"impact,omitempty"`
	} `json:"package_state"`
}

type Output struct {
	CVE         string
	Severity    string
	Component   string
	Information string
}

type PyxisResponse struct {
	Data []struct {
		Arch string   `json:"architecture"`
		CPEs []string `json:"cpe_ids"`
	} `json:"data"`
}

func PrettyPrint(i interface{}) string {
	s, _ := json.MarshalIndent(i, "", "\t")
	return string(s)
}

func CallHydra(cve_id string) HydraResponse {
	url := hydraUrl + cve_id + ".json"
	// Get request
	resp, err := http.Get(url)
	if err != nil {
		fmt.Println("No response from request")
	}
	defer resp.Body.Close()
	body, err := ioutil.ReadAll(resp.Body) // response body is []byte

	var result HydraResponse
	if err := json.Unmarshal(body, &result); err != nil { // Parse []byte to the go struct pointer
		fmt.Println("Can not unmarshal JSON")
	}
	return result
}

func CallPyxis(repository string, name string, tag string) []string {
	url := PyxisUrl + "/repositories/registry/registry.access.redhat.com/repository/" + repository + "/" + name + "/tag/" + tag
	//fmt.Println(url)
	// Get request
	resp, err := http.Get(url)
	if err != nil {
		fmt.Println("No response from request")
	}
	defer resp.Body.Close()
	body, err := ioutil.ReadAll(resp.Body) // response body is []byte

	var result PyxisResponse
	if err := json.Unmarshal(body, &result); err != nil { // Parse []byte to the go struct pointer
		fmt.Println("Can not unmarshal JSON")
	}

	var dirty_cpe_ids []string
	for _, look := range result.Data {
		if look.Arch == "amd64" {
			dirty_cpe_ids = append(dirty_cpe_ids, look.CPEs...)
		}
	}

	var cpe_ids []string
	var clean_cpe_ids []string
	for _, look := range dirty_cpe_ids {
		clean_cpe_ids = strings.Split(look, "::")
		cpe_ids = append(cpe_ids, clean_cpe_ids[0])
		cpe_ids = append(cpe_ids, look)
	}

	return cpe_ids
}

func fileExist(file_name string) bool {
	info, err := os.Stat(file_name)
	if os.IsNotExist(err) {
		return false
	}
	return !info.IsDir()
}

func processLines(wg *sync.WaitGroup, jobs <-chan []string, results chan<- Output) {
	defer wg.Done()
	for line_data := range jobs {
		//Collecting and grepping security data
		cve_id := line_data[0]
		//fmt.Printf("%v", cve_id)
		result := CallHydra(cve_id)

		var image_Repo string
		var image_Name string
		var image_Tag string
		var image_cpe_info []string
		var info_fixed []string
		var info_not_fixed []string
		var Information string
		var non_rpm_fixes_status []string
		var non_rpm_not_fixed_status []string

		//Collecting information about the reported component (package or container image)
		if strings.Contains(line_data[1], "/") {
			image_Repo = strings.Split(line_data[1], "/")[0]
			image_Name = strings.Split(strings.Split(line_data[1], "/")[1], ":")[0]
			image_Tag = strings.Split(strings.Split(line_data[1], "/")[1], ":")[1]
			//fmt.Printf("%v\n%v\n%v\n", image_Repo, image_Name, image_Tag)

			image_cpe_info = CallPyxis(image_Repo, image_Name, image_Tag)
			//fmt.Println(PrettyPrint(image_cpe_info))

			//Searching for rpm fixes based on the CPE
			for _, cpe := range image_cpe_info {
				for _, lookFixed := range result.Data_Fixed {
					if lookFixed.CPE == cpe {
						info_fixed = append(info_fixed, fmt.Sprintf("(%+v,%+v,%+v)", lookFixed.Product_name, lookFixed.Advisory, lookFixed.RPM))
					}
				}
				for _, lookNotFixed := range result.Data_NotFixed {
					if lookNotFixed.CPE == cpe {
						info_not_fixed = append(info_not_fixed, fmt.Sprintf("(%+v,%+v,%+v)", lookNotFixed.Product_name, lookNotFixed.Fix_State, lookNotFixed.RPM))
					}
				}
			}
			//Searching for non_rpm fixes based on the container name
			container_name := image_Repo + "/" + image_Name
			for _, addressed := range result.Data_Fixed {
				if strings.Contains(addressed.RPM, container_name) {
					non_rpm_fixes_status = append(non_rpm_fixes_status, fmt.Sprintf("(%+v,%+v,%+v)", addressed.Product_name, addressed.Advisory, addressed.RPM))
				}
			}
			for _, not_addressed := range result.Data_NotFixed {
				if strings.Contains(not_addressed.RPM, container_name) {
					non_rpm_not_fixed_status = append(non_rpm_not_fixed_status, fmt.Sprintf("(%+v,%+v,%+v)", not_addressed.Product_name, not_addressed.Fix_State, not_addressed.RPM))
				}
			}
		} else {
			//Fuzzy searching is as a component there is only a name of package, not a container image
			component_name := line_data[1]
			for _, addressed := range result.Data_Fixed {
				if strings.Contains(addressed.RPM, component_name) {
					info_fixed = append(info_fixed, fmt.Sprintf("(%+v,%+v,%+v)", addressed.Product_name, addressed.Advisory, addressed.RPM))
				}
			}
			for _, not_addressed := range result.Data_NotFixed {
				if strings.Contains(not_addressed.RPM, component_name) {
					info_not_fixed = append(info_not_fixed, fmt.Sprintf("(%+v,%+v,%+v)", not_addressed.Product_name, not_addressed.Fix_State, not_addressed.RPM))
				}
			}
		}

		//Generating the results
		if len(info_fixed) == 0 && len(info_not_fixed) == 0 && len(non_rpm_fixes_status) == 0 && len(non_rpm_not_fixed_status) == 0 {
			Information = "Not Found Any Information"
		} else {
			output1 := strings.Join(info_fixed, "")
			output2 := strings.Join(info_not_fixed, "")
			output3 := strings.Join(non_rpm_fixes_status, "")
			output4 := strings.Join(non_rpm_not_fixed_status, "")
			Information = fmt.Sprintf("%v%v%v%v", output1, output2, output3, output4)
		}
		// Summary := new(Output)
		var summary Output
		summary.CVE = cve_id
		summary.Component = line_data[1]
		summary.Severity = result.Severity
		summary.Information = Information

		results <- summary
	}
}

func main() {
	// Verification if provided file with data exists or not
	if len(os.Args) < 2 {
		fmt.Println("File to check is not provided")
		os.Exit(1)
	}
	file_name := os.Args[1]
	if fileExist(file_name) {
		fmt.Printf("Checking the %v\n", file_name)
	} else {
		fmt.Println("file to check is incorrect or not exist")
		os.Exit(1)
	}

	// Opening the file
	file, err := os.Open(file_name)
	if err != nil {
		fmt.Println("failed opening file")
	}
	defer file.Close()

	data := csv.NewReader(file)

	// Checking the data
	jobs := make(chan []string)
	results := make(chan Output, 50) // guess

	wg := sync.WaitGroup{}

	// 10 threads seem fair
	for w := 0; w < 10; w++ {
		wg.Add(1)
		go processLines(&wg, jobs, results)
	}

	for {
		line_data, err := data.Read()
		if err == io.EOF {
			break
		}

		jobs <- line_data
	}

	close(jobs)

	wg.Wait()

	close(results)

	for r := range results {
		fmt.Printf("%+v | %+v | %+v | %+v\n", r.CVE, r.Component, r.Severity, r.Information)
	}
}
