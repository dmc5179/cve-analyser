package helper

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
	"strings"
)

const PyxisUrl string = "https://catalog.redhat.com/api/containers/v1"

type PyxisResponse struct {
	Data []struct {
		Arch string   `json:"architecture"`
		CPEs []string `json:"cpe_ids"`
	} `json:"data"`
}

func unique(s []string) []string {
	inResult := make(map[string]bool)
	var result []string
	for _, str := range s {
		if _, ok := inResult[str]; !ok {
			inResult[str] = true
			result = append(result, str)
		}
	}
	return result
}

func CallPyxis_CPE(repository string, name string, tag string) []string {
	url := PyxisUrl + "/repositories/registry/registry.access.redhat.com/repository/" + repository + "/" + name + "/tag/" + tag
	//fmt.Println(url)
	// Get request
	resp, err := http.Get(url)
	if err != nil {
		fmt.Println("No response from request")
	}
	defer resp.Body.Close()
	body, err := ioutil.ReadAll(resp.Body) // response body is []byte

	var result PyxisResponse
	if err := json.Unmarshal(body, &result); err != nil { // Parse []byte to the go struct pointer
		fmt.Println("Can not unmarshal JSON")
	}

	var dirty_cpe_ids []string
	for _, look := range result.Data {
		if look.Arch == "amd64" {
			dirty_cpe_ids = append(dirty_cpe_ids, look.CPEs...)
		}
	}

	// generate list of CPEs with sw_edition and without
	var cpe_ids []string
	var clean_cpe_ids []string
	for _, look := range dirty_cpe_ids {
		clean_cpe_ids = strings.Split(look, "::")
		cpe_ids = append(cpe_ids, clean_cpe_ids[0])
		cpe_ids = append(cpe_ids, look)
	}

	return unique(cpe_ids)
}
