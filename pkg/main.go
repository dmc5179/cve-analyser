package main

import (
	"bufio"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
	"os"
	"strings"
)

const hydraUrl string = "https://access.redhat.com/hydra/rest/securitydata/cve/"
const PyxisUrl string = "https://catalog.redhat.com/api/containers/v1"

type HydraResponse struct {
	CVE          string `json:"name"`
	Severity     string `json:"threat_severity"`
	Statement    string `json:"statement"`
	Upstream_fix string `json:"upstream_fix"`
	Data_Fixed   []struct {
		Product_name   string `json:"product_name"`
		Advisory       string `json:"advisory"`
		CPE            string `json:"cpe"`
		RPM            string `json:"package"`
		Product_impact string `json:"impact,omitempty"`
	} `json:"affected_release"`
	Data_NotFixed []struct {
		Product_name   string `json:"product_name"`
		Fix_State      string `json:"fix_state"`
		CPE            string `json:"cpe"`
		RPM            string `json:"package_name"`
		Product_impact string `json:"impact,omitempty"`
	} `json:"package_state"`
}

type Output struct {
	CVE         string
	Component   string
	Information []string
}

type PyxisResponse struct {
	Data []struct {
		Arch string   `json:"architecture"`
		CPEs []string `json:"cpe_ids"`
	} `json:"data"`
}

func PrettyPrint(i interface{}) string {
	s, _ := json.MarshalIndent(i, "", "\t")
	return string(s)
}

func CallHydra(cve_id string) HydraResponse {
	url := hydraUrl + cve_id + ".json"
	// Get request
	resp, err := http.Get(url)
	if err != nil {
		fmt.Println("No response from request")
	}
	defer resp.Body.Close()
	body, err := ioutil.ReadAll(resp.Body) // response body is []byte

	var result HydraResponse
	if err := json.Unmarshal(body, &result); err != nil { // Parse []byte to the go struct pointer
		fmt.Println("Can not unmarshal JSON")
	}
	return result
}

func CallPyxis(repository string, name string, tag string) []string {
	url := PyxisUrl + "/repositories/registry/registry.access.redhat.com/repository/" + repository + "/" + name + "/tag/" + tag
	//fmt.Println(url)
	// Get request
	resp, err := http.Get(url)
	if err != nil {
		fmt.Println("No response from request")
	}
	defer resp.Body.Close()
	body, err := ioutil.ReadAll(resp.Body) // response body is []byte

	var result PyxisResponse
	if err := json.Unmarshal(body, &result); err != nil { // Parse []byte to the go struct pointer
		fmt.Println("Can not unmarshal JSON")
	}

	var dirty_cpe_ids []string
	for _, look := range result.Data {
		if look.Arch == "amd64" {
			dirty_cpe_ids = append(dirty_cpe_ids, look.CPEs...)
		}
	}

	var cpe_ids []string
	var clean_cpe_ids []string
	for _, look := range dirty_cpe_ids {
		clean_cpe_ids = strings.Split(look, "::")
		cpe_ids = append(cpe_ids, clean_cpe_ids[0])
	}

	return cpe_ids
}

func fileExist(file_name string) bool {
	info, err := os.Stat(file_name)
	if os.IsNotExist(err) {
		return false
	}
	return !info.IsDir()
}

func main() {

	// Verification if provided file with data exist
	if len(os.Args) < 2 {
		fmt.Println("File to check is not provided")
		os.Exit(1)
	}
	file_name := os.Args[1]
	if fileExist(file_name) {
		fmt.Printf("Checking the %v\n", file_name)
	} else {
		fmt.Println("file to check is incorrect or not exist")
		os.Exit(1)
	}

	// Opening file
	file, err := os.Open(file_name)

	if err != nil {
		fmt.Println("failed opening file")
	}
	defer file.Close()

	reader := bufio.NewScanner(file)
	reader.Split(bufio.ScanLines)
	var data []string
	for reader.Scan() {
		data = append(data, reader.Text())
	}

	// Checking the data

	for _, lines := range data {

		line_data := strings.Split(lines, ",")

		//Collecting information about the reported container image
		image_Repo := strings.Split(line_data[1], "/")[0]
		image_Name := strings.Split(strings.Split(line_data[1], "/")[1], ":")[0]
		image_Tag := strings.Split(strings.Split(line_data[1], "/")[1], ":")[1]

		//fmt.Printf("%v\n%v\n%v\n", image_Repo, image_Name, image_Tag)
		image_cpe_info := CallPyxis(image_Repo, image_Name, image_Tag)
		//fmt.Println(PrettyPrint(image_cpe_info))

		//Collecting and grepping security data
		cve_id := line_data[0]
		fmt.Printf("%v\t", cve_id)
		result := CallHydra(cve_id)

		for _, cpe := range image_cpe_info {
			for _, lookFixed := range result.Data_Fixed {
				if lookFixed.CPE == cpe {
					fmt.Printf("[%+v,%+v,%+v]\n", lookFixed.Product_name, lookFixed.Advisory, lookFixed.RPM)
				}
			}
			for _, lookNotFixed := range result.Data_NotFixed {
				if lookNotFixed.CPE == cpe {
					fmt.Printf("[%+v,%+v,%+v]\n", lookNotFixed.Product_name, lookNotFixed.Fix_State, lookNotFixed.RPM)
				}
			}

		}

		//for _, look := range result.Data_NotFixed {
		//	fmt.Printf("%+v %+v\t", look.Product_name, look.Fix_State)
		//}

		//fmt.Println(PrettyPrint(result))

	}

}
