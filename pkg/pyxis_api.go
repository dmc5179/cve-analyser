package helper

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
	"sort"
	"strings"
)

const PyxisUrl string = "https://catalog.redhat.com/api/containers/v1"

type PyxisResponseCPE struct {
	Data []struct {
		Arch string   `json:"architecture"`
		CPEs []string `json:"cpe_ids"`
	} `json:"data"`
}

type PyxisResponseImageID struct {
	Data []struct {
		Arch string `json:"architecture"`
		ID   string `json:"_id"`
	} `json:"data"`
}

type PyxisResponseRPMmanifest struct {
	RPMs []struct {
		Name       string `json:"name"`
		SRPM_NAME  string `json:"srpm_name"`
		SRPM_NEVRA string `json:"srpm_nevra"`
	} `json:"rpms"`
}

func unique(s []string) []string {
	inResult := make(map[string]bool)
	var result []string
	for _, str := range s {
		if _, ok := inResult[str]; !ok {
			inResult[str] = true
			result = append(result, str)
		}
	}
	return result
}

func CallPyxis_CPE(repository string, name string, tag string) []string {
	url := PyxisUrl + "/repositories/registry/registry.access.redhat.com/repository/" + repository + "/" + name + "/tag/" + tag
	//fmt.Println(url)
	// Get request
	resp, err := http.Get(url)
	if err != nil {
		fmt.Println("No response from request")
	}
	defer resp.Body.Close()
	body, err := ioutil.ReadAll(resp.Body) // response body is []byte

	var result PyxisResponseCPE
	if err := json.Unmarshal(body, &result); err != nil { // Parse []byte to the go struct pointer
		fmt.Println("Can not unmarshal JSON")
	}

	var dirty_cpe_ids []string
	for _, look := range result.Data {
		if look.Arch == "amd64" {
			dirty_cpe_ids = append(dirty_cpe_ids, look.CPEs...)
		}
	}

	// generate list of CPEs with sw_edition and without
	var cpe_ids []string
	var clean_cpe_ids []string
	for _, look := range dirty_cpe_ids {
		clean_cpe_ids = strings.Split(look, "::")
		cpe_ids = append(cpe_ids, clean_cpe_ids[0])
		cpe_ids = append(cpe_ids, look)
	}
	return unique(cpe_ids)
}

func CallPyxis_ImageID(repository string, name string, tag string) string {
	url := PyxisUrl + "/repositories/registry/registry.access.redhat.com/repository/" + repository + "/" + name + "/tag/" + tag
	//fmt.Println(url)
	// Get request
	resp, err := http.Get(url)
	if err != nil {
		fmt.Println("No response from request")
	}
	defer resp.Body.Close()
	body, err := ioutil.ReadAll(resp.Body) // response body is []byte

	var result PyxisResponseImageID
	if err := json.Unmarshal(body, &result); err != nil { // Parse []byte to the go struct pointer
		fmt.Println("Can not unmarshal JSON")
	}

	var imageID string
	for _, look := range result.Data {
		if look.Arch == "amd64" {
			imageID = look.ID
		}
	}
	return imageID
}

func CallPyxis_RPMs(imageID string) []string {
	url := PyxisUrl + "/images/id/" + imageID + "/rpm-manifest"

	resp, err := http.Get(url)
	if err != nil {
		fmt.Println("No response from request")
	}
	defer resp.Body.Close()
	body, err := ioutil.ReadAll(resp.Body) // response body is []byte

	var result PyxisResponseRPMmanifest
	if err := json.Unmarshal(body, &result); err != nil { // Parse []byte to the go struct pointer
		fmt.Println("Can not unmarshal JSON")
	}

	var manifest []string
	for _, look := range result.RPMs {
		manifest = append(manifest, strings.Split(look.SRPM_NEVRA, ":")[0]) // collecting src packages names as image manifest, split by ":"
	}
	sort.Strings(manifest)
	return unique(manifest)
}
